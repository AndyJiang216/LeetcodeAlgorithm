package com.jianglong.dynamicAndGreddyAL;

import java.util.List;

/*动态规划算法*/
public class dynamicAL {
    /*爬楼梯*/
    /*假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？*/
    /*示例1：输入3；输出3
    * 解释：有三种方法可以爬到楼顶。
    *      1.1+1+1
    *      2.1+2
    *      3.2+1
    * */
    /*动态规划题目解析：
    * 问题拆解：到达第n个楼梯可以从第n-1个楼梯和第n-2个楼梯到达，因此第n个问题可以拆解为第n-1个问题和第n-2个问题，
    *          第n-1个问题和第n-2个问题又可以继续往下拆解，直到第0个问题，也就是第0个楼梯（起点）。
    * 状态定义：问题拆解中提到，第n个楼梯会和第n-1和第n-2个楼梯有关联，那么具体的联系是什么呢？第n-1个问题里面的答案其实是
    *          从起点到达第n-1个楼梯的路径总数，n-2同理。从n-1个楼梯可以到达第n个楼梯，从n-2个楼梯也可以，并且路径没有重复。
    *          因此我们可以把第i个状态定义为“从起点到达第i个楼梯的路径总数”，状态之间的联系其实是相加的关系。
    * 递推方程：“状态定义”中我们已经定义好了状态，也知道第i个状态可以由第i-1个状态和第i-2个状态相加得到，因此递推方程为
    *          dp[i]=dp[i-1]+dp[i-2]
    * 实现：从递推方程中可以看到，我们需要有一个初始值来方便我们计算，起始位置dp[0]=0，第一层楼梯只能从起始位置到达，因此dp[1]=1，
    *       第2层楼梯可以从起始位置和第1层楼梯到达，因此dp[2]=2，有了这些初始值，后面的值就可以通过这几个初始值进行地推得到。
    * */
    public int climbStairs(int n){
        if(n==1) return 1;
        int[] dp=new int[n+1];//多开一位，考虑起始位置
        dp[0]=0;dp[1]=1;dp[2]=2;
        for(int i=3;i<=n;i++){
            dp[i]=dp[i-1]+dp[i-2];
        }
        return dp[n];
    }

    /*三角形最小路径和*/
    /*给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。*/
    /*例如，给定三角形：
    * [
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]* */
    /*动态规划题目解析：
     * 问题拆解：这里的总问题是求出最小的路径和，路径是这里的分析重点，路径是由一个个元素组成的，和之前爬楼梯那道题目类似，[i][j] 位置的元素，
     *          经过这个元素的路径肯定也会经过 [i - 1][j] 或者 [i - 1][j - 1]，因此经过一个元素的路径和可以通过这个元素上面的一个或者两个元素的路径和得到。
     * 状态定义：状态的定义一般会和问题需要求解的答案联系在一起，这里其实有两种方式，一种是考虑路径从上到下，另外一种是考虑路径从下到上，
     *          因为元素的值是不变的，所以路径的方向不同也不会影响最后求得的路径和，如果是从上到下，你会发现，在考虑下面元素的时候，起始元素的路径只会从[i - 1][j] 获得，
     *          每行当中的最后一个元素的路径只会从 [i - 1][j - 1] 获得，中间二者都可，这样不太好实现，因此这里考虑从下到上的方式，
     *          状态的定义就变成了 “最后一行元素到当前元素的最小路径和”，对于 [0][0] 这个元素来说，最后状态表示的就是我们的最终答案。
     * 递推方程：dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + triangle[i][j]
     * 实现：这里初始化时，我们需要将最后一行的元素填入状态数组中，然后就是按照前面分析的策略，从下到上计算即可.
     * */
    public int minimunTotal(List<List<Integer>> triangle){
        int n=triangle.size();
        int[][] dp=new int[n][n];
        List<Integer> lastRow=triangle.get(n-1);

        for (int i = 0; i < n; i++) {
            dp[n-1][i]=lastRow.get(i);
        }
        for (int i = n-2; i >= 0; i--) {
            List<Integer> row=triangle.get(i);//从下往上开始数当前行的元素数组
            for (int j = 0; j < i+1; j++) {
                dp[i][j]=Math.min(dp[i+1][j],dp[i+1][j+1])+row.get(j);//当前行每一个元素对应的最小路径和等于与他相邻的下一行的两个元素中较小的那一个，再加上他本身的值。
            }
        }

        return dp[0][0];
    }

    /*最大子序和*/
    /*给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。*/
    /*例如，输入: [-2,1,-3,4,-1,2,1,-5,4],
            输出: 6
            解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
    * */
    /*动态规划题目解析：
     * 问题拆解：问题的核心是子数组，子数组可以看作是一段区间，因此可以由起始点和终止点确定一个子数组，两个点中，我们先确定一个点，然后去找另一个点，比如说，
     * 如果我们确定一个子数组的截止元素在 i 这个位置，这个时候我们需要思考的问题是 “以 i 结尾的所有子数组中，和最大的是多少？”，然后我们去试着拆解，这里其实只有两种情况：
        i 这个位置的元素自成一个子数组;
        i 位置的元素的值 + 以 i - 1 结尾的所有子数组中的子数组和最大的值
        你可以看到，我们把第 i 个问题拆成了第 i - 1 个问题，之间的联系也变得清晰
     * 状态定义：通过上面的分析，其实状态已经有了，dp[i] 就是 “以 i 结尾的所有子数组的最大值”
     * 递推方程：dp[i] = Math.max(array[i], dp[i-1]+array[i])
     *          化简一下可以得到：
     *          dp[i]=Math.max(dp[i-1],0)+array[i]
     * 实现：题目要求子数组不能为空，因此一开始需要初始化，也就是 dp[0] = array[0]，保证最后答案的可靠性，另外我们需要用一个变量记录最后的答案，因为子数组有可能以数组中任意一个元素结尾
     * */
    public int maxSubArray(int[] array){
        if(array==null||array.length==0) return 0;
        int[] dp=new int[array.length];
        dp[0]=array[0];
        int result=dp[0];
        for (int i = 1; i < dp.length; i++) {
            dp[i]=Math.max(dp[i-1],0)+array[i];//以数组第i个位置为结尾的子数组最大和等于以前一位置为结尾的子数组最大和加上当前位置数组元素和与单独当前数组元素的最大值
            result=Math.max(result,dp[i]);//比较当前位置子数组最大和结果与前一位置子数组最大和结果，更新函数返回结果
        }
        return result;
    }

    public static void main(String[] args) {
        dynamicAL dynamicAL=new dynamicAL();
        int[] array={-1,1,-3,4,-1,2,1,-5,4};
        System.out.println(dynamicAL.maxSubArray(array));
    }
}
