package com.jianglong.dynamicAndGreddyAL;

/*动态规划进阶版：矩阵动态规划*/
public class dynamicSeniorAL {
    /*不同路径*/
    /*一个机器人位于一个 m x n 网格的左上角,机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角,问总共有多少条路径*/
    /*例如，输入: m = 3, n = 2
            输出: 3
            解释:
            从左上角开始，总共有 3 条路径可以到达右下角。

            1. 向右 -> 向右 -> 向下
            2. 向右 -> 向下 -> 向右
            3. 向下 -> 向右 -> 向右
    * */
    /*动态规划题目解析：
     * 问题拆解：题目中说了，每次移动只能是向右或者是向下，矩阵类动态规划需要关注当前位置和其相邻位置的关系，对于某一个位置来说，经过它的路径只能从它上面过来，或者从它左边过来，
     *          因此，如果需要求到达当前位置的不同路径，我们需要知道到达其上方位置的不同路径，以及到达其左方位置的不同路径。
     * 状态定义：矩阵类动态规划的状态定义相对来说比较简单，只需要看当前位置即可，问题拆解中，我们分析了当前位置和其邻居的关系，提到每个位置其实都可以算做是终点，
     *          状态表示就是 “从起点到达该位置的不同路径数目”
     * 递推方程：dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
     * 实现：有了这些，这道题还没完，我们还要考虑状态数组的初始化问题，对于上边界和左边界的点，因为它们只能从一个方向过来，需要单独考虑，比如上边界的点只能从左边这一个方向过来，
     *       左边界的点只能从上边这一个方向过来，它们的不同路径个数其实就只有 1，提前处理就好。
     * */
    public int countRoutes(int m,int n){
        if(m<=0||n<=0||m>100||n>100) return 0;
        if(m==1||n==1) return 1;
        int[][] dp=new int[n][m];

        for (int i = 0; i < m; ++i) {//初始化第一列的元素，因为只能向下走，所有均为1
            dp[i][0] = 1;
        }

        for (int j = 0; j < n; ++j) {//初始化第一列的元素，因为只能向右走，所有均为1
            dp[0][j] = 1;
        }

        for (int i = 1; i < n; i++) {
            for (int j = 1; j < m; j++) {
                dp[i][j]=dp[i-1][j]+dp[i][j-1];//从小向大依次计算动态规划结果，而非从大到小递推
            }
        }
        return dp[n-1][m-1];
    }

    /*不同路径2*/
    /*一个机器人位于一个 m x n 网格的左上角,机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角,
      现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？（网格中的障碍物和空位置分别用1和0进行标示）*/
    /*例如，输入:
            [
              [0,0,0],
              [0,1,0],
              [0,0,0]
            ]
            输出: 2
            解释:
            3x3 网格的正中间有一个障碍物。
            从左上角到右下角一共有 2 条不同的路径：

            1. 向右 -> 向右 -> 向下 -> 向下
            2. 向下 -> 向下 -> 向右 -> 向右
    * */
    /*动态规划题目解析：
     * 在上面那道题的基础上，矩阵中增加了障碍物，这里只需要针对障碍物进行判断即可，如果当前位置是障碍物的话，状态数组中当前位置记录的答案就是 0，
     * 也就是没有任何一条路径可以到达当前位置，除了这一点外，其余的分析方法和解题思路和之前 一样 。
     * */
    public int countRoutesWithObstacles(int[][] obstacleGrid){
        if(obstacleGrid.length==0||obstacleGrid[0].length==0) return 0;
        if(obstacleGrid[0][0]==1) return 0;
        int m=obstacleGrid.length,n=obstacleGrid[0].length;
        int[][] dp=new int[m][n];
        dp[0][0]=1;

        for (int i = 1; i < m; i++) {
            dp[i][0]=obstacleGrid[i][0]==1?0:dp[i-1][0];
        }
        for (int i = 1; i < n; i++) {
            dp[0][i]=obstacleGrid[0][i]==1?0:dp[0][i-1];
        }

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j]=obstacleGrid[i][j]==1?0:dp[i-1][j]+dp[i][j-1];
            }
        }

        return dp[m-1][n-1];
    }

    /*最大正方形*/
    /*在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。*/
    /*例如，输入:
            1 0 1 0 0
            1 0 1 1 1
            1 1 1 1 1
            1 0 0 1 0
            输出: 4
    * */
    /*动态规划题目解析：
     * 问题拆解：我们可以思考，如果我们从左到右，然后从上到下遍历矩阵，假设我们遍历到的当前位置是正方形的右下方的点，那其实我们可以看之前我们遍历过的点有没有可能和当前点组成符合条件的正方形，
     *          除了这个点以外，无非是要找另外三个点，这三个点分别在当前点的上方，左方，以及左上方，也就是从这个点往这三个方向去做延伸，具体延伸的距离是和其相邻的三个点中的状态有关
     * 状态定义：因为我们考虑的是正方形的右下方的顶点，因此状态可以定义成 “当前点为正方形的右下方的顶点时，正方形的最大面积”
     * 递推方程：有了状态，我们再来看看递推方程如何写，前面说到我们可以从当前点向三个方向延伸，我们看相邻的位置的状态，这里我们需要取三个方向的状态的最小值才能确保我们延伸的是全为 ‘1’ 的正方形，也就是
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
     * 实现：在实现上，我们需要单独考虑两种情况，就是当前位置是 ‘1’，还有就是当前位置是 ‘0’，如果是 ‘0’ 的话，状态就是 0，表示不能组成正方形，如果是 ‘1’ 的话，我们也需要考虑位置，
     *      如果是第一行的元素，以及第一列的元素，表明该位置无法同时向三个方向延伸，状态直接给为 1 即可，其他情况就按我们上面得出的递推方程来计算当前状态。
     * */
    public int maximalSquare(char[][] matrix){
        if(matrix.length==0||matrix[0].length==0) return 0;
        int m=matrix.length,n=matrix[0].length;
        int[][] dp=new int[m][n];
        int maxLength=0;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if(matrix[i][j]=='1'){
                    if(i==0||j==0){
                        dp[i][j]=matrix[i][j]=='1'?1:0;
                    }else {
                        dp[i][j]= Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;//若以当前元素为右下角的正方形其他三个相邻顶点的元素中存在0，则对应的最大面积正方形仍是他自己，即边长为一
                    }
                    maxLength=Math.max(dp[i][j],maxLength);
                }
            }
        }

        return maxLength*maxLength;
    }
}
